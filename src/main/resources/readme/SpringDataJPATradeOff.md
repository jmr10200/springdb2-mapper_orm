#### 스프링 데이터 JPA - 트레이드 오프

##### 예제
```
ItemService 는 ItemRepository 인터페이스에 의존한다.
JpaItemRepositoryV2가 구현체이다.
또, SpringDataJpaItemRepository 에 의존한다.
```
중간에서 JpaItemRepositoryV2 가 어댑터 역할을 해준 덕분에 MemberService 가 사용하는 MemberRepository 인터페이스를
그대로 유지할 수 있고 클라이언트인 MemberService 의 코드를 변경하지 않아도 되는 장점이 있다.

***고민***<br>
구조를 맞추기 위해서 중간에 어댑터가 들어가게 되면서 전체구조가 너무 복잡해지고 사용하는 클래스도 많아지게 됐다.<br>
유지보수 관점에서 ItemService 를 변경하지 않고, ItemRepository 의 구현체를 변경할 수 있는 장점이 있다.<br>
DI, OCP 원칙을 지킬 수 있다는 장점이 있다. 하지만 반대로 구조가 복잡해 어댑터코드와 실제코드까지 유지보수해야 된다.

***다른 선택***<br>
ItemService 코드를 일부 고쳐서 직접 스프링 데이터 JPA 를 사용하도록 하는 방법도 있다.<br>
DI, OCP 원칙을 포기하는 대신에, 어댑터를 제거하여 구조를 단순하게 하는 것이다.

***트레이드 오프***<br>
이것이 바로 트레이드 오프이다.<br>
DI, OCP 를 지키기 위해 어댑터를 도입하고, 더 많은 코드를 유지한다.<br>
어댑터를 제거하고 구조를 단순하게 가져가지만, DI, OCP 를 포기하고 ItemRepository 를 직접 변경한다.<br>
<br>
즉, 여기서 발생하는 트레이드 오프는 구조의 안정성 vs 단순한 구조와 개발의 편리성 사이의 선택이다.<br>
정답이 있는 것은 아니다. 상황에 따라 구조의 안정성이, 단순한 구조가 더 우선될 수 있다.<br>
<br>
유지보수 관점에서 추상화도 비용이 든다. 어설픈 추상화는 오히려 독이 된다.<br>
이 추상화 비용을 넘어설 만큼 효과가 있을 때 추상화를 도입하는 것이 실용적이다.<br>
